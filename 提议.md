编码基本法
AI 如同一个精力无限、知识渊博的初级开发者，能以惊人的速度为我们搭建功能、编写函数、解决算法问题。
然而，一个严峻的现实摆在我们面前：AI生成的代码，其默认质量往往停留在“能运行”，而非“健壮可靠”的水平。
想象一下，你团队里来了一位新人，他聪明绝顶、学习飞快，但缺乏项目经验。
如果你只是简单地告诉他：“去，实现一个用户登录功能”，你可能会得到一个能用的结果，但很可能伴随着以下问题：
● 风格不一致： 他可能这次用 require，下次用 import。
● 缺乏防御： 他可能没有对用户输入进行充分的校验，留下了安全隐患。
● 错误处理草率： 他可能忘记了处理网络请求失败的 catch 块。
● 难以测试： 他的代码可能将所有逻辑耦合在一起，让你无法进行单元测试。
● 忽视规范： 他不知道团队推崇的命名约定和设计模式。
我们与AI的协作，与此情景何其相似。AI就是那位“天赋异禀但缺乏规范”的开发者。
如果我们仅仅满足于向它下达模糊的指令，我们就会花费大量的时间去审查、重构和修复它产出的“原型级”代码，最终反而降低了整体效率。

那么，如何将这位“初级开发者”提升为能够与我们并肩作战的“高级工程师”呢？
答案是：我们不能仅仅是它的“任务分派者”，更要成为它的“架构师”和“导师”。 

在我们开始任何实质性的编码协作之前，我们必须先为它建立一套清晰、严格、不可动摇的规则——一部“编码宪法”。
这份“宪法”定义了我们项目中关于代码质量、健壮性、安全性和可维护性的所有基本原则。
它将作为我们与AI之间沟通的基石，确保AI在后续生成的每一行代码中，都内嵌了工程卓越的最佳实践。

通过预先设定这套规则，我们将AI的行为从“随机猜测”转变为“有章可循”，将我们的协作模式从“反复修正”提升到“一步到位”。
接下来，我们将详细介绍这部为AI量身定制的JavaScript“编码宪法”。
它不仅是一份提示词，更是我们引导AI产出高质量工程代码的核心方法论。

### 面向生产的JavaScript代码生成宪法

**角色设定与核心指令 (Role & Core Directive):**

你是一名资深的JavaScript架构师，你的首要任务是产出**生产级别**的、高度健壮、安全且可维护的代码。
在本次会话中，你生成的所有JavaScript代码都**必须**严格、无条件地遵循以下编码宪法。这些规则是不可协商的。

---

#### **1. 核心语言与语法 (Modern & Strict)**

*   **模块系统:** **必须**只使用ESM (`import`/`export`)。**禁止**使用CommonJS (`require`/`module.exports`)。
*   **异步编程:** **必须**对所有异步操作使用 `async/await`，并将其包裹在 `try...catch` 块中进行错误处理。**禁止**使用裸露的 `.then()` 链或回调函数。
*   **面向对象:** **必须**使用 `class` 语法进行面向对象的设计，包括构造函数、继承和方法定义。
*   **变量声明:** **禁止**使用 `var`。**必须**默认使用 `const`，仅在变量需要被重新赋值时才使用 `let`。

#### **2. 健壮性与防御性编程 (Robust & Defensive)**

*   **输入验证:** **必须**在每个函数的入口处，对所有外部传入的参数进行严格的类型和值校验。对无效输入，**必须**立即抛出具体的错误（如 `TypeError`, `RangeError`）。
*   **错误处理:** **绝不允许**静默失败。每个潜在的异常点都**必须**被捕获和处理。错误消息**必须**清晰、具有描述性。
*   **数据不可变性:** **必须**优先使用不可变数据结构。在操作数组和对象时，使用非破坏性方法（如 `map`, `filter`, `reduce`, 扩展运算符 `...`），**禁止**直接修改原始数据。
*   **函数设计:** **必须**优先编写纯函数。将有副作用的操作（如I/O、API调用）与核心业务逻辑严格分离。

#### **3. 代码质量与可维护性 (Clean & Maintainable)**

*   **命名规范:** **必须**严格遵守命名约定：函数/变量为 `camelCase`，类为 `PascalCase`，常量为 `UPPER_SNAKE_CASE`。命名**必须**做到自解释。
*   **代码格式化:** **必须**统一采用 Prettier 的默认风格进行格式化（2空格缩进、使用分号等）。
*   **文档化:**
    *   **必须**为所有公开的函数、类和方法编写 JSDoc 注释，清晰描述其功能、`@param`、`@returns` 和 `@throws`。
    *   对于复杂的内部逻辑，**必须**添加注释来解释“为什么”这么做，而不是“做了什么”。

#### **4. 可测试性 (Testable by Design)**

*   **依赖注入:** **必须**通过依赖注入（函数参数、构造函数注入）来管理依赖关系。**禁止**在函数或类内部硬编码或直接实例化依赖，以确保代码的可测试性。
*   **生成单元测试:** 在生成任何业务逻辑（函数或类）时，**必须**同时提供一个使用 Jest 或 Vitest 框架的配套单元测试文件 (`*.test.js`)。测试**必须**覆盖成功路径、边界条件和错误情况。

#### **5. 安全性 (Secure by Default)**

*   **输入净化:** **必须**对所有用于数据库查询、HTML渲染或命令执行的外部输入进行严格的净化和转义，以防止XSS、SQL注入等所有类型的注入攻击。
*   **秘密管理:** **严禁**在代码中硬编码任何敏感信息（API密钥、密码等）。**必须**通过环境变量 (`process.env`) 进行管理。在日志输出中，**必须**对敏感字段进行脱敏处理。

#### **6. 性能与资源管理 (Performant & Efficient)**

*   **算法效率:** **必须**在处理数据集合时，选择时间复杂度和空间复杂度最优的算法。**避免**在循环中执行昂贵的同步操作。
*   **内存管理:** **必须**主动管理资源，防止内存泄漏。确保及时清理不再使用的事件监听器、定时器和对象引用，尤其是在单页应用（SPA）的组件生命周期中。

#### **7. 架构原则 (Well-Architected)**

*   **单一职责:** **必须**遵循单一职责原则。每个函数、类或模块只做一件事，并把它做好。保持其小巧和专注。


效果示例
向AI提供完全相同的、描述业务需求的提示词。
统一的任务提示词:
我需要为Node.js应用编写一段逻辑，用来处理用户头像的更新。
功能需求如下：
1. 它应该能接收一个 userId 和一个新的 avatarUrl。
2. 它需要使用一个叫 dbClient 的数据库客户端来根据 userId 查找用户。如果用户不存在，需要处理这个错误。
3. 在更新头像前，它必须调用一个叫 moderationService 的外部服务，来检查 avatarUrl 指向的图片是否安全。如果图片不安全，也需要处理这个错误。
4. 只有当用户存在且图片安全时，才使用 dbClient 更新数据库中用户的头像信息。
5. 最后，它应该返回更新后的用户信息。
请为我生成实现这个逻辑的JavaScript代码。

场景 A: 标准提问
我们开启一个全新的AI会话，直接输入上述统一的任务提示词。
AI可能产出的“标准”代码：
// updateUserAvatar.js

// 依赖被直接引入和硬编码
const dbClient = require('./dbClient');
const moderationService = require('./moderationService');

async function updateUserAvatar(userId, avatarUrl) {
  // 1. 输入验证比较基础
  if (!userId || !avatarUrl) {
    throw new Error('User ID and Avatar URL are required.');
  }

  try {
    // 2. 业务逻辑紧密耦合
    const user = await dbClient.findUserById(userId);
    if (!user) {
      // 3. 错误处理比较笼统
      throw new Error('User not found.');
    }

    const isSafe = await moderationService.isImageSafe(avatarUrl);
    if (!isSafe) {
      throw new Error('Image content is not safe.');
    }

    const updatedUser = await dbClient.updateUser(userId, { avatar: avatarUrl });

    return updatedUser;

  } catch (error) {
    // 4. 无法区分错误来源，日志记录可能缺失
    console.error(`Failed to update avatar for user ${userId}:`, error.message);
    // 向上抛出，但调用者难以处理
    throw error;
  }
}

// 5. 使用了 CommonJS 模块系统
module.exports = { updateUserAvatar };
代码质量分析 (标准输出的问题):
● 难以测试: 这是最大的问题。因为 dbClient 和 moderationService 是在文件内部直接 require 的，我们无法在单元测试中轻松地模拟(mock)它们。要测试这个函数，我们必须连接真实的数据库和外部服务，这使得测试变得缓慢、昂贵且不可靠。
● 模块化和复用性差: 这是一个孤立的函数，如果未来有更多与用户相关的操作（如修改密码、更新个人资料），我们将不得不创建更多类似的孤立函数，而不是将它们组织在一个内聚的 UserService 中。
● 健壮性不足: 错误处理是“一刀切”的。调用者捕获到一个 Error，但无法通过编程方式知道失败的具体原因是“用户不存在”还是“图片不安全”，从而难以实现针对性的重试或用户提示逻辑。
● 代码规范不统一: 使用了现在已非首选的CommonJS模块系统。没有文档注释，可读性和可维护性随着逻辑变复杂会迅速下降。

场景 B: 预设“编码宪法”
我们开启一个新会话。
首先，输入我们优化后的“编码宪法”。
AI确认理解后，我们再输入与场景A一模一样的统一的任务提示词。
AI遵循“编码宪法”产出的高质量代码：
文件 1: src/services/UserService.js
(AI会主动选择创建一个Class，因为“宪法”强调了单一职责和面向对象的设计)
import { UserNotFoundError, ModerationError, InvalidInputError } from '../errors/customErrors.js';

/**
 * @class UserService
 * @description Manages user-related business logic, ensuring testability and robustness.
 */
export class UserService {
  #dbClient;
  #moderationService;

  /**
   * Constructs the UserService with its dependencies.
   * @param {object} dbClient - An instance of the database client.
   * @param {object} moderationService - An instance of the image moderation service.
   */
  constructor(dbClient, moderationService) {
    // 规则 4.1 (依赖注入): 依赖通过构造函数传入，而不是硬编码
    this.#dbClient = dbClient;
    this.#moderationService = moderationService;
  }

  /**
   * Updates a user's avatar from a URL after validation and moderation.
   * @param {string} userId - The ID of the user to update.
   * @param {string} avatarUrl - The new avatar URL.
   * @returns {Promise<object>} The updated user object.
   * @throws {InvalidInputError} If userId or avatarUrl are invalid.
   * @throws {UserNotFoundError} If the user cannot be found.
   * @throws {ModerationError} If the image URL is deemed unsafe.
   */
  async updateAvatar(userId, avatarUrl) {
    // 规则 2.1 (输入验证): 在入口处进行严格校验
    if (!userId || typeof userId !== 'string' || !avatarUrl || typeof avatarUrl !== 'string') {
      throw new InvalidInputError('Valid string inputs for userId and avatarUrl are required.');
    }

    // 规则 1.2 (async/await): 所有异步操作都包裹在 try/catch 中
    try {
      const user = await this.#dbClient.findUserById(userId);
      if (!user) {
        // 规则 2.2 (错误处理): 抛出具体的、自定义的错误
        throw new UserNotFoundError(`User with ID "${userId}" not found.`);
      }

      const isSafe = await this.#moderationService.isImageSafe(avatarUrl);
      if (!isSafe) {
        throw new ModerationError('The provided image URL was rejected by the moderation service.');
      }

      return this.#dbClient.updateUser(userId, { avatar: avatarUrl });
    } catch (error) {
      // 规则 2.2: 确保错误被显式处理和传递
      if (error instanceof UserNotFoundError || error instanceof ModerationError || error instanceof InvalidInputError) {
        throw error; // 重新抛出已知的业务逻辑错误
      }
      // 将未知的底层错误（如数据库连接失败）包装成一个通用但清晰的错误
      throw new Error(`An unexpected error occurred while updating the avatar: ${error.message}`);
    }
  }
}
文件 2: tests/UserService.test.js
(AI会主动生成测试文件，因为“宪法”规则 4.2 强制要求)
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { UserService } from '../src/services/UserService.js';
import { UserNotFoundError, ModerationError } from '../src/errors/customErrors.js';

// 模拟依赖项
const mockDbClient = {
  findUserById: vi.fn(),
  updateUser: vi.fn(),
};
const mockModerationService = {
  isImageSafe: vi.fn(),
};

describe('UserService.updateAvatar', () => {
  let userService;

  beforeEach(() => {
    vi.resetAllMocks();
    userService = new UserService(mockDbClient, mockModerationService);
  });

  it('should update avatar successfully when user exists and image is safe', async () => {
    mockDbClient.findUserById.mockResolvedValue({ id: 'user-1' });
    mockModerationService.isImageSafe.mockResolvedValue(true);
    mockDbClient.updateUser.mockResolvedValue({ id: 'user-1', avatar: 'safe-url' });

    await expect(userService.updateAvatar('user-1', 'safe-url')).resolves.toBeDefined();
    expect(mockDbClient.updateUser).toHaveBeenCalledWith('user-1', { avatar: 'safe-url' });
  });

  it('should throw UserNotFoundError if user is not found', async () => {
    mockDbClient.findUserById.mockResolvedValue(null);
    await expect(userService.updateAvatar('user-404', 'any-url')).rejects.toThrow(UserNotFoundError);
  });

  it('should throw ModerationError if image is not safe', async () => {
    mockDbClient.findUserById.mockResolvedValue({ id: 'user-1' });
    mockModerationService.isImageSafe.mockResolvedValue(false);
    await expect(userService.updateAvatar('user-1', 'unsafe-url')).rejects.toThrow(ModerationError);
  });
});
结论对比
特性	场景 A (标准提问)	场景 B (预设“宪法”)	为什么场景 B 更好？
代码结构	孤立的函数	内聚的 class	可扩展性：更容易添加新方法，管理用户相关的全部逻辑。
模块系统	CommonJS (require)	ESM (import/export)	现代化：遵循官方标准，有利于静态分析和打包优化。
依赖管理	硬编码导入	依赖注入	可测试性：这是最重要的区别。代码解耦，可以在测试中轻松模拟依赖。
错误处理	笼统的 Error	具体的自定义错误	健壮性：调用者可以精确捕获并处理不同类型的失败。
文档	无	完整的 JSDoc	可维护性：代码自解释，方便团队协作和长期维护。
测试	无	自动生成单元测试	可靠性：代码质量得到保证，可以安全地进行重构和迭代。
这个对比清晰地表明，同样的任务输入，仅仅因为预先加载了一套高质量的开发原则，AI的输出就从一个“能用”的原型，跃升为了一个“专业”的、符合现代软件工程最佳实践的生产级代码。 这证明了“编码宪法”的巨大价值。
